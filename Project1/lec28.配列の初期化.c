#include<stdio.h>

int main(void) {

	int n[] = { 5,4,3,2,1,0 };
	int i;
	for (i = 0; i <6 ; i++) {
		printf("n[%d]= %d ", i, n[i]);
		//配列の範囲外にアクセスすると、未定義動作とされ予期せぬ動作をしたり、
		//プログラムがクラッシュする可能性がある。
		//C言語では配列の範囲外にアクセスしてもエラーが出ないため注意が必要。
		
		/*↑を防ぐには二つの方法があるとのこと。
		１つが、「配列の要素数を変数で管理する方法」
		#include<stddef.h>　　←size_t型を使うためにヘッダーファイルを読み込む。
		#define array_size 6　←マクロで配列のサイズを定義している。
								#defineで定義されたマクロ名（例：ARRAY_SIZE）を、
								指定されたテキスト（例：6）にすべて置き換える。
								Excelのマクロとは異なり、C言語のマクロは
								コンパイル前に別の文字列（数値でもOK）に置き換える機能を持つ。
		int main(void){
			int n[array_size] = { 5,4,3,2,1,0 };
			size_t i; size_tは符号無し整数型と言い、
			配列の要素数を管理するのに適している。
			z: size_t型を表す。（sやtはすでに他の書式指定子で使われているのでzとのこと。）
			u: unsigned int（符号なし整数）を表す。

			for (i = 0; i < array_size; i++) {
				printf("n[%zu]= %d ", i, n[i]); %zuは主にsize_t型の書式指定子として使われる。
			}
			printf("\n");
			return 0;
		}
		2つ目が「コンパイル時にsizeof()演算子を使って配列要素数を自動計算させる方法」
		sizeofはコンパイラによって特別に扱われる演算子。関数と違い実行時ではなく、
		コンパイル時にコンパイラによって計算される。
		#include<stddef.h>
		int main(void){
			int n[]={5,4,3,2,1,0};
			size_t array_size = sizeof(n)/sizeof(n[0]);

			//sizeof(n)は配列nの全体のサイズをバイト単位で返す。
			//int型のサイズは通常4バイト。4*6=24バイト。
			//これをsizeof(n[0])つまり配列の最初の要素のサイズで割ることで、
			//配列の要素数を計算している。今回の例では24/4=6となる。
		*/
	}
	printf("\n");
	return 0;
}